![Image](https://github.com/user-attachments/assets/7f8d2feb-00e4-4e2b-b639-794078c64e03)

## 문제 접근

1. 숫자의 순서를 유지하면서 일부 숫자를 제거해서 가장 큰 수를 만들어야 되니까
   만들어야 할 수의 길이만큼 반복문을 돌리면서
   각 자리에서 선택 가능한 범위 내에서 가장 큰 수를 고르면 되겠다고 생각했다.
2. 예를 들어 "1231234"에서 3자리를 제거해서 총 4자리로 구성된 큰 수를 만들어된다면?

   첫 번째 자리: 최종 숫자를 만들기 위해 뒤쪽에 3자리를 남겨둔 채, 앞에서부터 4자리 중 가장 큰 숫자를 선택
   두 번째 자리: 첫 번째로 선택한 숫자 다음 자리부터 뒤쪽에 2자리를 확보한 상태에서 선택 가능한 범위 내에서 가장 큰 숫자를 선택
   세 번째 자리: 두 번째로 선택한 숫자 다음 자리부터 뒤쪽에 1자리를 확보한 상태에서 선택 가능한 범위 내에서 가장 큰 숫자를 선택
   네 번째 자리: 남은 숫자들 중에서 가장 큰 숫자를 선택

3. 반복문이 4번 돌아간다면 각 순회마다 선택 가능한 범위는

   0~3: 첫 번째 자리는 0번째 인덱스부터 3번째 인덱스까지 중에서 2번째 인덱스가 가장 큼
   3~4: 두 번째 자리는 3번째 인덱스부터 4번째 인덱스까지 중에서 4번째 인덱스가 가장 큼
   5~5: 세 번째 자리는 5번째 인덱스부터 5번째 인덱스까지 중에서 5번째 인덱스가 가장 큼
   6~6: 네 번째 자리는 6번째 인덱스부터 6번째 인덱스까지 중에서 6번째 인덱스가 가장 큼
   즉 4번 반복할때마다 위처럼 범위가 변하도록 구현하면 되겠다고 생각했다.

## 문제 풀이

1. 최종적으로 만들어야 할 숫자의 길이는 number.length - k이기 때문에
   이 길이만큼 반복문을 돌면서 각 자리에 들어갈 숫자를 하나씩 선택한다.
2. 선택 가능한 시작 인덱스는 처음에 0으로 설정하고
   하나의 숫자가 선택될 때마다, 그 숫자의 다음 인덱스부터 탐색을 이어가도록 시작 위치를 갱신한다.
3. 선택 가능한 끝 인덱스는 현재 반복문의 인덱스 + k로 앞으로 선택할 숫자들을 위해 뒤쪽 자릿수를 충분히 남겨두는 조건을 만족하게 한다.
4. 범위 내에서 가장 큰 숫자 하나를 선택하고 이 과정을 필요한 숫자의 길이만큼 반복한다.
   다.

![Image](https://github.com/user-attachments/assets/377a0c49-d598-41d8-8f91-387287f926cb)

> 바로 해결하나 싶었지만 시간초과가 발생하는 테스트케이스가 있었다.
> 그래서 불필요하게 순회하는 경우가 있을까 생각해봤는데
> 숫자 9가 가장 크니까 9인 경우에는 순회를 바로 종료해도 된다는 점이 떠올랐고
> break문만 추가해주니 해결이 됐다.

```jsx
function solution(number, k) {
  let currentIndex = 0;
  let result = '';

  for (let i = 0; i < number.length - k; i++) {
    let maxNumber = '0';

    for (let j = currentIndex; j <= k + i; j++) {
      if (number[j] > maxNumber) {
        maxNumber = number[j];
        currentIndex = j;

        if (maxNumber === '9') break; // 추가
      }
    }

    result += maxNumber;
    currentIndex = currentIndex + 1;
  }

  return result;
}
```

## 다른 풀이와의 차이

> 다른 풀이 중 하나는 스택을 활용한 방식으로
> 문자열을 앞에서부터 하나씩 순회하면서
> 현재 숫자가 이전에 넣은 숫자보다 크면,
> 이전 숫자를 pop하고 k를 감소시키는 식으로
> 작은 숫자를 제거하는 방식이다.
> 시간복잡도가 `O(n)` 수준인데

> 반면 내가 사용한 방식은
> 각 자릿수마다 선택 가능한 범위를 지정하고,
> 그 범위 내에서 가장 큰 수를 탐색하는 구조이고
> 탐색 범위가 넓어지면 반복횟수가 많아질 수 있기 때문에 최악의 경우 시간복잡도는 `O(n²)`까지 증가할 수 있다.
> 스택을 활용한 방식이
> 불필요한 범위 탐색이 없고
> 한 번의 순회로 숫자를 정리할 수 있기 때문에 시간 복잡도 면에서 더 효율적인 것 같다

> 무엇이 더 그리디스러운지 궁금해서 GPT에게 물어봤다.

<aside>
🤖

GPT:

> mySolution은 그리디 알고리즘의 정의에 가장 충실한 방식으로,
> 각 자릿수마다 선택 가능한 범위에서 직접 가장 큰 수를 선택하는 구조다.
> 즉, 탐욕적 선택(Greedy Choice)의 전형적인 형태를 따른다.

> 반면 stackSolution은 실용성을 고려한 최적화된 구현으로,
> 모든 숫자를 한 번만 순회하면서 불필요한 수를 제거하고,
> 더 큰 수를 빠르게 결정함으로써 성능을 극대화한 방식이다.

> 이처럼 두 알고리즘 모두 그리디 전략을 기반으로 하고 있지만,
> mySolution은 개념적으로 정석적인 구조,
> stackSolution은 현실적으로 효율적인 구조라 할 수 있다.

> 결국 그리디 알고리즘은 매 순간 최적의 선택을 반복하는 전략이지만,
> 현실 세계에서는 속도와 자원 효율성을 고려한 근사해 추구 방식으로도 널리 활용된다.
> 따라서 실제 서비스나 대용량 데이터를 다루는 상황에서는
> stackSolution처럼 현실적인 최적화를 반영한 그리디 구현이 더 적합할 수 있다.

</aside>

```jsx
function solution(number, k) {
  const result = [];
  number.split('').forEach(el => {
    while (k > 0 && result[result.length - 1] < el) {
      result.pop();
      k--;
    }

    result.push(el);
  });
  return result.slice(0, result.length - k).join('');
}
```

## 문제점 & 깨달은 점

> 전체 숫자를 조합해서 최적의 답을 찾기보다는
> 현재 선택 가능한 범위 내에서 최댓값을 찾아내고 곧바로 결과에 추가하는 방식을 사용했다.
> 앞으로 남은 숫자들이 어떤 조합을 만들 수 있을지는 따지지 않고,
> 바로 가장 큰 수를 선택하는 것이 어느정도 탐욕적인 접근이 아니었나 생각한다.

> 스택 개념을 통해 이 문제를 더욱 효율적으로 해결할 수 있다는 점도 배울 수 있었고,
> 점점 문제 푸는 재미도 생기는 것 같다.

## Reference

https://taesung1993.tistory.com/46

## 문제 접근

이 문제는 “9214”와 같은 숫자로 이루어진 문자열에서, K개의 숫자를 제거했을 때 가장 큰 수를 찾는 문제이다.

그래서 자연스럽게 문자열을 탐색하면서 푸는 방법을 생각해봤는데, 30분 넘게 고민해봐도 완전 탐색, 여러 번 탐색 하는 방법 말고는 도저히 생각이 안 났다.

그나마 고민했던 방법은 다음과 같다.

1. **가장 큰 숫자**를 찾아야 한다. 그 숫자가 **최대한 앞자리에 오도록** 가장 큰 숫자 뒤로 최대한 선택한다.
    - 근데 이런 식으로 가장 큰 숫자가 어디 있는 지 탐색하면 시간복잡도가 너무 커지니까, 1회 탐색할 때 큰 숫자 순위를 별도로 저장해야 하나? 생각했다.
    - 별도로 저장해도 여러 번 탐색해야 하는 것은 매한가지였다. 배열에 저장한다면 해당 배열도 여러 번 탐색해야 되니.
2. 아니면 **큰 숫자가 앞에 있을수록 큰 숫자를 만들기 유리하니 가중치**를 계산해야 하나? (인덱스와 숫자를 더한다던가)
    - “4177252841” 숫자가 있을 때 인덱스를 더하면 [4, 2, 10, 11, 6, 10, 8, 15, 12, 10]이 되는데, 4개를 제거해야 한다면 [4, 2, 10, 11, 6, 10, 8, 15, 12, 10] 이렇게 제거하고, “775841”
    - 어? 되네? 이게 되네? 왜 안된다고 생각했지?
    - 이렇게 할 때의 문제점은 또 작은 숫자부터 제거하기 위해 탐색을 해야 한다는 거?
    - 정렬을 활용해 볼까? 배열에 인덱스도 같이 저장할까? 한번 해보자..!
    
    ```jsx
    function solution(number, k) {
        const answer = [...number];
        const numbers = [...number].map(Number);
        // 각 자리수에 인덱스를 더함 (가중치)
        const numbers_with_weight = numbers.map((num, i) => {
            return [num + i, i];
        })
        // 가중치 기준으로 오름차순 정렬
        const sorted = numbers_with_weight.sort((a, b) => a[0] - b[0]);
        // 작은 가중치를 가진 순서대로 숫자의 인덱스를 알아내고 K개 제거
        for (let i = 0; i < k; i++) {
            answer[sorted[i][1]] = '';
        }
        // 정답 반환
        return answer.join('');
    }
    ```
    
    - 응 열심히 코드 작성해봤지만 테케만 통과되고 제출하니 대부분 오답이다 🥲

역시 모르겠다!

다른 사람 풀이를 찾아보자!

## 문제 풀이

검색해보니까 스택을 활용해서 푸는 것이라고 한다. 

스택이라는 단어만 듣고 혼자 풀어보려고 했는데 여전히 어려워서 전체 풀이를 참고했다.

숫자를 순회하면서 스택에 push 하되, 현재 숫자가 스택의 top의 숫자보다 크다면, k개만 제거하는 것을 유념해 top에 있는 숫자를 제거하는 방식으로 풀면 된다고 한다.

```jsx
function solution(number, k) {
  let stack = [];

  for (let i = 0; i < number.length; i++) {
    const element = numbeㅋr[i];
    // stack 마지막 숫자와 현재 숫자를 비교하여 현재 숫자가 더 크면 stack의 마지막 숫자 pop
    while (k > 0 && stack[stack.length - 1] < element) {
      stack.pop();
      k--;
    }
    stack.push(element);
  }

  // 모든 숫자 비교가 끝난 후, k가 0보다 크다면 남은 k만큼 뒤에서 제거
  stack.splice(stack.length - k, k);
  return stack.join("");
}
```

전체 풀이를 보았지만 여전히 궁금했던 점은 아래 두 가지였다.

1. 어떻게 스택을 활용해야 한다는 아이디어까지 도달할 수 있는 지?
2. 큰 수를 만들기 위한 규칙을 어떻게 알 수 있었는지?

구글링 했을 때는 그저 ‘스택을 사용하면 풀리더라’와 같은 결과론 적인 해설들만 있길래

`ChatGPT`한테 문제를 던지면서 위 두 가지 질문을 해봤다.


이 문제를 보고 스택을 사용해야 한다는 판단을 어떻게 할 수 있지?
큰 수를 만드는 규칙이 뭐지?

### ChatGPT의 말:

좋은 질문이에요! 이 문제에서 **스택을 사용해야 한다는 판단**과, **큰 수를 만드는 규칙**을 어떻게 파악하는지 같이 알아보죠.

---

## 🔍 **문제에서 파악해야 할 핵심**

1. **앞에서부터 숫자를 하나씩 보면서 결정**해야 함.
2. 가능한 **왼쪽 숫자가 클수록 큰 수**가 만들어짐.
3. 하지만 **k개의 숫자를 반드시 제거**해야 함.
4. 즉, **현재 숫자가 이전 숫자보다 클 경우, 이전 숫자를 제거하는 것이 더 큰 수를 만드는 데 유리함.**

이것이 바로 **"스택"을 써야 한다는 힌트**가 되는 부분이에요.

---

## ✅ **왜 스택인가? (스택 사용 판단 근거)**

- **이전 숫자와 비교해서** 필요하면 **제거**하고 싶음 → 최근의 숫자들을 기억해야 함.
- 가장 최근 숫자들 중에서 **현재 숫자보다 작은 숫자**를 제거하는 게 유리 → 이건 **후입선출(LIFO)** 구조, 즉 스택!
- **앞에서부터 숫자를 순차적으로 처리**하면서, 조건에 따라 뒤로 돌아가서 처리하는 느낌이 필요 → 이것도 스택에 잘 맞음.

---

## 💡 **큰 수를 만드는 규칙**

1. **왼쪽 자리부터 큰 숫자**를 유지해야 함.
2. 현재 숫자가 스택의 top보다 크고, 제거할 기회(k)가 남아 있다면 → 스택에서 pop (제거)
3. 그렇다고 무조건 다 제거하면 안 되므로 **k가 남아 있는 한도 내에서만 제거**
4. 숫자를 모두 순회하고 나면, 남은 숫자들을 순서대로 붙이기

---

## 예제 시뮬레이션 (예: "1924", k = 2)

### 목표: 2개의 숫자를 제거 → 2자리 숫자 남기기

| **현재 숫자** | **스택 상태** | **남은 k** | **설명** |
| --- | --- | --- | --- |
| 1 | [1] | 2 | 첫 숫자 push |
| 9 | [9] | 1 | 9가 1보다 크므로 1 제거 |
| 2 | [9, 2] | 1 | 2는 9보다 작음, 그대로 push |
| 4 | [9, 4] | 0 | 4는 2보다 크지만 제거 기회 없음 |

📌 최종 결과: `"94"`

---

## ✨ 코드로 구현하면:

```python
python
복사편집
def solution(number, k):
    stack = []
    for num in number:
        while stack and k > 0 and stack[-1] < num:
            stack.pop()
            k -= 1
        stack.append(num)

    # k가 남아있다면 뒤에서 k개 제거
    if k > 0:
        stack = stack[:-k]

    return ''.join(stack)

```

---

## 정리하자면:

- **앞에서부터 숫자를 보며, 현재 숫자가 스택 top보다 크면 제거!**
- **이 과정에서 최근 값만 보고 판단하므로 → 스택!**
- **가장 큰 숫자를 만들기 위해 작은 숫자는 제거해야 함 (하지만 너무 많이 제거하면 안 됨)**

</aside>

GPT가 하는 설명을 보고 나니 좀 더 명확히 이해가 되었다.

처음에 큰 숫자가 최대한 앞으로 오는 것이 유리하다는 문제 접근은 올바르게 한 것 같고,

이때 숫자를 순회하면서 이전 숫자가 더 작다면 제거하되 나머지 숫자는 남기면서 순회를 계속한다는 점에서 스택을 떠올릴 수 있음을 알았다.

다시 스스로 코드를 작성해봤다.

```jsx
function solution(number, k) {
    stack = [];
    
    for(let i = 0; i < number.length; i++){
        while(k > 0 && Number(number[i]) > stack[stack.length - 1]){
            stack.pop();
            k--;
        };
        stack.push(Number(number[i]));
    };
    
    if(k > 0){
        stack.splice(-1, k);
    }
    
    return stack.join('');
}
```

이 문제는 나중에 복기해야겠다!

## 문제점 & 깨달은 점

문제 접근부터 막혀서 문제점은 딱히 없고, 깨달은 점은 이런 유형의 문제를 풀 때 좀 더 테스트 케이스를 여러 개 만들어보면서 규칙을 더 세부화 하고, 자료구조를 사용할 수는 없을 지 고민해보는 것이 좋겠다는 점이다.

## Reference

https://velog.io/@yeguu037/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0-JavaScript
